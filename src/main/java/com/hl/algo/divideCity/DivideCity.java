package com.hl.algo.divideCity;

import java.math.BigInteger;

/**
 * IOI 题目:
 * n个城市，1~n
 * m个双向连接 1~m, 每个连接，连接两个城市a,b
 * 可行解：
 * 将n个城市划分为A,B,C三个子集（规模分别为a,b,c），满足：至少两个子集是连通的。
 *
 * 输入：n,m,
 * m的连接，
 * A,B,C的规模a,b,c
 *
 * 输出：
 * 任意一个可行解: 即集合A,B,C各自包含的具体城市标号
 * 如果无解，输出无解。
 *
 * 规模：n<=2500, m<=5000
 * 时间限制：1分钟
 */
public class DivideCity {



    /**
     * 算法分析
     *
     * 任意两个集合C,D，集合大小C<D，如果一个城市组合(x1,x2,...xc)刚好放入C，且他们连通，则将其放入D中也必然连通。
     * 如果找不到这样的组合满足能放入C且连通，则也找不到这样的组合放入D连通。
     * 因此集合大小越小，就容易找到连通的子集。
     *
     * a,b,c给定后，按照规模从小到大顺序排列，分别为a',b',c'，对应集合A',B',C'规模也是从小到大顺序。
     * 我们只要依次找到A',B'的组合，使A',B'连通，则找到了解。否则就是无解。
     *
     * 无解的条件：
     * 如果有解，则至少有a',b'个点，以及它们的连接线个数 a'+b'-2
     * 如果m<a'+b'-2,则一定无解
     *
     * 由于B'比A'难求，因此可以先计算B'，如果B'无解，则总体无解。
     *
     * 先选a'个城市组合，再选b'个城市组合，总的可能的组合数为：C(n,a)*C(n-a,b)=n!/(a!(n-a)!)*(n-a)!/(b!(n-a-b)!)
     * 试算组合数很大，所以用穷举法不可行。
     */
    void analysis() {
        // 组合数最多的情况
        int n = 2500;
        int a = n/2;
        int b = n-a;
        BigInteger nn = fac(n);
        BigInteger nComb1 = fac(n).divide(fac(a)).divide(fac(n-a));
        BigInteger nComb2 = fac(n-a).divide(fac(b)).divide(fac(n-a-b));
        BigInteger nComb = nComb1.multiply(nComb2);

        System.out.println("comb number:"+nComb);
        //comb number:5996747843879727010446034750704879594589642330081728571047014061721602054236827424066853583653214345317231901852809276951453488917246864436113036781633346653784807909853233470017653461203008934723274411227996848083467997291789654100090704530254271834955239446638598463463603725241943670645308798092914381274804810715111871026290607464929695407747361109295225211914838428789871075426430033781291071953038208600626781350439139868806691669992124884739760249982470690702558066909456447383538712647210360893379880018358591103233063966107174651963480056805263721863341173540121258450592572011293683093517188337776678516511322530224839233531808516500724345588736023386297879901427185034262239853347934813877454202900114017433903211294289102934197769359372256
    }



    /**
     * 求阶乘 x!
     * @param x
     * @return x!
     */
    static BigInteger fac(int x) {
        BigInteger p = BigInteger.ONE;
        for (int i=1;i<=x;i++) {
            p = p.multiply(BigInteger.valueOf(i));
        }
        return p;
    }


    /**
     * 算法：
     * 1. a,b,c排序，按照从小到大设置为a,b,c
     * 1.剪枝, 去掉所有degree(x) = 0的点x。  degree(x) = x的边数
     * 2.剩下的点S中，判断 if 总点数count(S) < a+b, 则无解
     * 3.对S的点，按照degree从大到小排序，选取前a+b个点
     * 4.用进化算法：
     *   （1）初始化S中a个点放入A,b个点放入B，AB组成染色体C，求染色体的适应度fit。
     *   （2）若代数g> 最大代数G, 则未找到解，退出.
     *   （3) 判断A，B是否全连通，如果满足，则返回A,B；否则下一步.
     *   （4）交换A,B中一对点，形成C'=A'B',求染色体适应度fit'
     *   （5）如果fit'<fit, 则重复（4）;否则用新的染色体作为下一代：C=C'，代数g := g+1， 重复（2）
     * */
    void solve() {

    }

    public static void main(String[] args) {
        DivideCity d = new DivideCity();
        d.analysis();
        //System.out.println(fac(0));
    }
}
