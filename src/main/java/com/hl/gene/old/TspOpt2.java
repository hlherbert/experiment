package com.hl.gene.old;//  Improvement Tsp with 2-Opt algorithm.
//
//# where G is the graph and W is the weights of edges
//	    def 2opt(G=(V,E), W):
//	        # where tour is a list of vertices with assumed edges
//	        tour = random_tour(V)
//	        do:
//	            best_improvement = 0
//	            best_i, best_j = 0
//	            # we only need to iterate through the first half of the edges,
//	            # since the rest would be redundant
//	            for i from 0 upto len(tour) / 2 + 1:
//	                first_edge_u = i     # u represents the first vertex in the edge
//	                first_edge_v = i + 1 # v represents the second vertex in the edge
//	                # based on the second edge's v, we should stop 3 sooner
//	                for j from 0 upto len(tour) - 3:
//	                    second_edge_u = (i + j + 2) % len(tour)
//	                    second_edge_v = (i + j + 3) % len(tour)
//	                    old_edge_dists = W[tour[first_edge_u], tour[first_edge_v]] 
//	                                   + W[tour[second_edge_u], tour[second_edge_v]]
//	                    new_edge_dists = W[tour[first_edge_u], tour[second_edge_u]] 
//	                                   + W[tour[first_edge_v], tour[second_edge_v]]
//	                    improvement = old_edge_dists - new_edge_dists
//	                    if improvement > best_improvement:
//	                        best_improvement = improvement
//	                        best_i = first_edge_u
//	                        best_j = second_edge_u
//	            if best_improvement > 0:
//	                # swap the "middle" vertices
//	                tour.swap((best_i + 1) % len(tour), best_j)
//	        while best_improvement > 0
//	        return tour

/**
 * Opt-2 improvement for TSP
 * @author hl
 *
 */
public class TspOpt2 {

	
	// Reverse the array segment [i~j]
	private static void reverse(int[] tour, int i, int j)
	{
		while (i<j)
		{
			int tmp = tour[i];
			tour[i]=tour[j];
			tour[j]=tmp;
			
			i++;
			j--;
		}
	}
	
	/**
	 * Improve current tour.
	 * This function only need call one time.
	 * More times of calling this function do not get better solution.
	 * The input tour represented a cycle, it must start from 0, and not closed.
	 * E.g  tour = (0,1,2) , represents the travel cycles(1,2,3,1).
	 * @param n      number of cities
	 * @param tour   current tour,  can be generated by a greedy algorithm.
	 *               It will be changed to a better path when finished this function
	 * @param cost   the cost matrix of cities
	 */
	public static void ImproveOpt2(int n, int[] tour, double[][] cost)
	{
		double best_improvement=0;
		do
		{
            best_improvement = 0;
            int best_i=0, best_j = 0;
            //# we only need to iterate through the first half of the edges,
            //# since the rest would be redundant
            for (int i=0;i<n/2+1;i++)
            {
                int first_edge_u = i;// # u represents the first vertex in the edge
                int first_edge_v = i + 1;// # v represents the second vertex in the edge
                //# based on the second edge's v, we should stop 3 sooner
                for (int j=0;j<n-3;j++)
                {
                	int second_edge_u = (i + j + 2) % n;
                	int second_edge_v = (i + j + 3) % n;
                    double old_edge_dists = cost[tour[first_edge_u]][tour[first_edge_v]] 
                                   + cost[tour[second_edge_u]][tour[second_edge_v]];
                    double new_edge_dists = cost[tour[first_edge_u]][tour[second_edge_u]] 
                                   + cost[tour[first_edge_v]][tour[second_edge_v]];
                    double improvement = old_edge_dists - new_edge_dists;
                    if (improvement > best_improvement)
                    {
                        best_improvement = improvement;
                        best_i = first_edge_u;
                        best_j = second_edge_u;
                    }
                }
            }
            if (best_improvement > 0)
            {
                //# swap the "middle" vertices
            	reverse( tour,(best_i + 1) %n, best_j);
            }
        } while (best_improvement > 0);
	}
	
}
